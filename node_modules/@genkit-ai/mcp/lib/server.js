"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var server_exports = {};
__export(server_exports, {
  GenkitMcpServer: () => GenkitMcpServer
});
module.exports = __toCommonJS(server_exports);
var import_genkit = require("genkit");
var import_logging = require("genkit/logging");
var import_schema = require("genkit/schema");
var import_tool = require("genkit/tool");
class GenkitMcpServer {
  ai;
  options;
  server;
  actionsResolved = false;
  toolActions = [];
  promptActions = [];
  resourceActions = [];
  /**
   * Creates an instance of GenkitMcpServer.
   * @param ai The Genkit instance whose actions will be exposed.
   * @param options Configuration options for the MCP server, like its name and version.
   */
  constructor(ai, options) {
    this.ai = ai;
    this.options = options;
  }
  /**
   * Initializes the MCP server instance and registers request handlers. It
   * dynamically imports MCP SDK components and sets up handlers for listing
   * tools, calling tools, listing prompts, and getting prompts. It also
   * resolves and stores all tool and prompt actions from the Genkit instance.
   *
   * This method is called by the constructor and ensures the server is ready
   * before any requests are handled. It's idempotent.
   */
  async setup() {
    if (this.actionsResolved) return;
    const { Server } = await import("@modelcontextprotocol/sdk/server/index.js");
    this.server = new Server(
      { name: this.options.name, version: this.options.version || "1.0.0" },
      {
        capabilities: {
          prompts: {},
          tools: {},
          resources: {}
        }
      }
    );
    const {
      CallToolRequestSchema,
      GetPromptRequestSchema,
      ListPromptsRequestSchema,
      ListToolsRequestSchema,
      ListResourcesRequestSchema,
      ListResourceTemplatesRequestSchema,
      ReadResourceRequestSchema
    } = await import("@modelcontextprotocol/sdk/types.js");
    this.server.setRequestHandler(
      ListToolsRequestSchema,
      this.listTools.bind(this)
    );
    this.server.setRequestHandler(
      CallToolRequestSchema,
      this.callTool.bind(this)
    );
    this.server.setRequestHandler(
      ListPromptsRequestSchema,
      this.listPrompts.bind(this)
    );
    this.server.setRequestHandler(
      ListResourcesRequestSchema,
      this.listResources.bind(this)
    );
    this.server.setRequestHandler(
      ListResourceTemplatesRequestSchema,
      this.listResourceTemplates.bind(this)
    );
    this.server.setRequestHandler(
      ReadResourceRequestSchema,
      this.readResource.bind(this)
    );
    this.server.setRequestHandler(
      GetPromptRequestSchema,
      this.getPrompt.bind(this)
    );
    const allActions = await this.ai.registry.listActions();
    const toolList = [];
    const promptList = [];
    const resourceList = [];
    for (const k in allActions) {
      if (k.startsWith("/tool/")) {
        toolList.push(allActions[k]);
      } else if (k.startsWith("/prompt/")) {
        promptList.push(allActions[k]);
      } else if (k.startsWith("/resource/")) {
        resourceList.push(allActions[k]);
      }
    }
    this.toolActions = toolList;
    this.promptActions = promptList;
    this.resourceActions = resourceList;
    this.actionsResolved = true;
  }
  /**
   * Handles MCP requests to list available tools.
   * It maps the resolved Genkit tool actions to the MCP Tool format.
   * @param req The MCP ListToolsRequest.
   * @returns A Promise resolving to an MCP ListToolsResult.
   */
  async listTools(req) {
    await this.setup();
    return {
      tools: this.toolActions.map((t) => {
        const def = (0, import_tool.toToolDefinition)(t);
        return {
          name: def.name,
          inputSchema: def.inputSchema || { type: "object" },
          description: def.description,
          _meta: t.__action.metadata?.mcp?._meta
        };
      })
    };
  }
  /**
   * Handles MCP requests to call a specific tool. It finds the corresponding
   * Genkit tool action and executes it with the provided arguments. The result
   * is then formatted as an MCP CallToolResult.
   * @param req The MCP CallToolRequest containing the tool name and arguments.
   * @returns A Promise resolving to an MCP CallToolResult.
   * @throws GenkitError if the requested tool is not found.
   */
  async callTool(req) {
    await this.setup();
    const tool = this.toolActions.find(
      (t) => t.__action.name === req.params.name
    );
    if (!tool)
      throw new import_genkit.GenkitError({
        status: "NOT_FOUND",
        message: `Tried to call tool '${req.params.name}' but it could not be found.`
      });
    const result = await tool(req.params.arguments);
    return {
      content: [
        {
          type: "text",
          text: typeof result === "string" ? result : JSON.stringify(result)
        }
      ]
    };
  }
  /**
   * Handles MCP requests to list available prompts.
   * It maps the resolved Genkit prompt actions to the MCP Prompt format,
   * including converting input schemas to MCP argument definitions.
   * @param req The MCP ListPromptsRequest.
   * @returns A Promise resolving to an MCP ListPromptsResult.
   */
  async listPrompts(req) {
    await this.setup();
    return {
      prompts: this.promptActions.map((p) => {
        return {
          name: p.__action.name,
          description: p.__action.description,
          arguments: toMcpPromptArguments(p),
          _meta: p.__action.metadata?.mcp?._meta
        };
      })
    };
  }
  /**
   * Handles MCP requests to list available resources.
   * It maps the resolved Genkit resource actions to the MCP Resource format.
   * @param req The MCP ListResourcesRequest.
   * @returns A Promise resolving to an MCP ListResourcesResult.
   */
  async listResources(req) {
    await this.setup();
    return {
      resources: this.resourceActions.filter((r) => r.__action.metadata?.resource.uri).map((r) => {
        return {
          name: r.__action.name,
          description: r.__action.description,
          uri: r.__action.metadata?.resource.uri,
          _meta: r.__action.metadata?.mcp?._meta
        };
      })
    };
  }
  /**
   * Handles MCP requests to list available resources.
   * It maps the resolved Genkit resource actions to the MCP Resource format.
   * @param req The MCP ListResourcesRequest.
   * @returns A Promise resolving to an MCP ListResourcesResult.
   */
  async listResourceTemplates(req) {
    await this.setup();
    return {
      resourceTemplates: this.resourceActions.filter((r) => r.__action.metadata?.resource.template).map((r) => {
        return {
          name: r.__action.name,
          description: r.__action.description,
          uriTemplate: r.__action.metadata?.resource.template,
          _meta: r.__action.metadata?.mcp?._meta
        };
      })
    };
  }
  /**
   * Handles MCP requests to list available resources.
   * It maps the resolved Genkit resource actions to the MCP Resource format.
   * @param req The MCP ListResourcesRequest.
   * @returns A Promise resolving to an MCP ListResourcesResult.
   */
  async readResource(req) {
    await this.setup();
    const resource = this.resourceActions.find(
      (r) => r.matches({ uri: req.params.uri })
    );
    if (!resource) {
      throw new import_genkit.GenkitError({
        status: "NOT_FOUND",
        message: `Tried to call resource '${req.params.uri}' but it could not be found.`
      });
    }
    const result = await resource({ uri: req.params.uri });
    return {
      contents: toMcpResourceMessage(req.params.uri, result.content)
    };
  }
  /**
   * Handles MCP requests to get (render) a specific prompt. It finds the
   * corresponding Genkit prompt action, executes it with the provided
   * arguments, and then formats the resulting messages into the MCP
   * PromptMessage format.
   * @param req The MCP GetPromptRequest containing the prompt name and
   * arguments.
   * @returns A Promise resolving to an MCP GetPromptResult.
   * @throws GenkitError if the requested prompt is not found.
   */
  async getPrompt(req) {
    await this.setup();
    const prompt = this.promptActions.find(
      (p) => p.__action.name === req.params.name
    );
    if (!prompt)
      throw new import_genkit.GenkitError({
        status: "NOT_FOUND",
        message: `[MCP Server] Tried to call prompt '${req.params.name}' but it could not be found.`
      });
    const result = await prompt(req.params.arguments);
    return {
      description: prompt.__action.description,
      messages: result.messages.map(toMcpPromptMessage)
    };
  }
  /**
   * Starts the MCP server with the specified transport or a default
   * StdioServerTransport. Ensures the server is set up before connecting the
   * transport.
   * @param transport Optional MCP transport instance. If not provided, a
   * StdioServerTransport will be created and used.
   */
  async start(transport) {
    if (!transport) {
      const { StdioServerTransport } = await import("@modelcontextprotocol/sdk/server/stdio.js");
      transport = new StdioServerTransport();
    }
    await this.setup();
    await this.server.connect(transport);
    import_logging.logger.debug(
      `[MCP Server] MCP server '${this.options.name}' started successfully.`
    );
  }
}
function toMcpPromptArguments(p) {
  const jsonSchema = (0, import_schema.toJsonSchema)({
    schema: p.__action.inputSchema,
    jsonSchema: p.__action.inputJsonSchema
  });
  if (!jsonSchema) return void 0;
  if (!jsonSchema.properties)
    throw new import_genkit.GenkitError({
      status: "FAILED_PRECONDITION",
      message: "[MCP Server] MCP prompts must take objects as input schema."
    });
  const args = [];
  for (const k in jsonSchema.properties) {
    const { type, description } = jsonSchema.properties[k];
    if (type !== "string" && (!Array.isArray(type) || !type.includes("string"))) {
      throw new import_genkit.GenkitError({
        status: "FAILED_PRECONDITION",
        message: `[MCP Server] MCP prompts may only take string arguments, but ${p.__action.name} has property '${k}' of type '${type}'.`
      });
    }
    args.push({
      name: k,
      description,
      required: jsonSchema.required?.includes(k)
    });
  }
  return args;
}
const ROLE_MAP = { model: "assistant", user: "user" };
function toMcpPromptMessage(messageData) {
  if (messageData.role !== "model" && messageData.role !== "user") {
    throw new import_genkit.GenkitError({
      status: "UNIMPLEMENTED",
      message: `[MCP Server] MCP prompt messages do not support role '${messageData.role}'. Only 'user' and 'model' messages are supported.`
    });
  }
  const message = new import_genkit.Message(messageData);
  const common = { role: ROLE_MAP[messageData.role] };
  if (message.media) {
    const { url, contentType } = message.media;
    if (!url.startsWith("data:"))
      throw new import_genkit.GenkitError({
        status: "UNIMPLEMENTED",
        message: `[MCP Server] MCP prompt messages only support base64 data images.`
      });
    const mimeType = contentType || url.substring(url.indexOf(":") + 1, url.indexOf(";"));
    const data = url.substring(url.indexOf(",") + 1);
    return { ...common, content: { type: "image", mimeType, data } };
  } else {
    return { ...common, content: { type: "text", text: message.text } };
  }
}
function toMcpResourceMessage(uri, content) {
  return content.map((p) => {
    if (p.media) {
      const { url, contentType } = p.media;
      if (!url.startsWith("data:"))
        throw new import_genkit.GenkitError({
          status: "UNIMPLEMENTED",
          message: `[MCP Server] MCP resource messages only support base64 data images.`
        });
      const mimeType = contentType || url.substring(url.indexOf(":") + 1, url.indexOf(";"));
      const data = url.substring(url.indexOf(",") + 1);
      return { uri, mimeType, blob: data };
    } else if (p.text) {
      return { uri, text: p.text };
    } else {
      throw new import_genkit.GenkitError({
        status: "UNIMPLEMENTED",
        message: `[MCP Server] MCP resource messages only support media and text parts.`
      });
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GenkitMcpServer
});
//# sourceMappingURL=server.js.map