{"version":3,"sources":["../../src/util/tools.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport type {\n  CallToolResult,\n  Tool,\n} from '@modelcontextprotocol/sdk/types.js' with { 'resolution-mode': 'import' };\nimport { JSONSchema7, z, type Genkit, type ToolAction } from 'genkit';\nimport { logger } from 'genkit/logging';\n\nconst toText = (c: CallToolResult['content']) =>\n  c.map((p) => p.text || '').join('');\n\nfunction processResult(result: CallToolResult) {\n  if (result.isError) return { error: toText(result.content) };\n  if (result.content.every((c) => !!c.text)) {\n    const text = toText(result.content);\n    if (text.trim().startsWith('{') || text.trim().startsWith('[')) {\n      try {\n        return JSON.parse(text);\n      } catch (e) {\n        return text;\n      }\n    }\n    return text;\n  }\n  if (result.content.length === 1) return result.content[0];\n  return result;\n}\n\n/**\n * Registers a single MCP tool as a Genkit tool.\n * It defines a new Genkit tool action that, when called, will\n * interact with the MCP client to execute the corresponding MCP tool.\n *\n * @param ai The Genkit instance to define the tool on.\n * @param client The MCP client instance used to interact with the MCP server.\n * @param tool The MCP Tool object to register.\n * @param params Contains the Genkit client name, MCP server name for namespacing,\n *               and a flag for raw tool responses.\n */\nfunction registerTool(\n  ai: Genkit,\n  client: Client,\n  tool: Tool,\n  params: { serverName: string; name: string; rawToolResponses?: boolean }\n) {\n  logger.debug(\n    `[MCP] Registering tool '${params.name}/${tool.name}'' from server '${params.serverName}'`\n  );\n  ai.defineTool(\n    {\n      name: `${params.serverName}/${tool.name}`,\n      description: tool.description || '',\n      inputJsonSchema: tool.inputSchema as JSONSchema7,\n      outputSchema: z.any(),\n      metadata: { mcp: { _meta: tool._meta || {} } },\n    },\n    async (args) => {\n      logger.debug(\n        `[MCP] Calling MCP tool '${params.serverName}/${tool.name}' with arguments`,\n        JSON.stringify(args)\n      );\n      const result = await client.callTool({\n        name: tool.name,\n        arguments: args,\n      });\n      if (params.rawToolResponses) return result;\n      return processResult(result as CallToolResult);\n    }\n  );\n}\n\n/**\n * Creates a Genkit dynamic tool action for a given MCP tool.\n * This is similar to `registerTool` but returns the `ToolAction` directly\n * instead of defining it on the Genkit instance.\n *\n * @param ai The Genkit instance, used for creating the dynamic tool.\n * @param client The MCP client instance.\n * @param tool The MCP Tool object.\n * @param params Configuration parameters including namespacing and raw response flag.\n * @returns A Genkit `ToolAction` representing the MCP tool.\n */\nfunction createDynamicTool(\n  ai: Genkit,\n  client: Client,\n  tool: Tool,\n  params: { serverName: string; name: string; rawToolResponses?: boolean }\n): ToolAction {\n  return ai.dynamicTool(\n    {\n      name: `${params.serverName}/${tool.name}`,\n      description: tool.description || '',\n      inputJsonSchema: tool.inputSchema as JSONSchema7,\n      outputSchema: z.any(),\n      metadata: { mcp: { _meta: tool._meta || {} } },\n    },\n    async (args, { context }) => {\n      logger.debug(\n        `[MCP] calling tool '${params.serverName}/${tool.name}' in host '${params.name}'`\n      );\n      const result = await client.callTool({\n        name: tool.name,\n        arguments: args,\n        _meta: context?.mcp?._meta,\n      });\n      if (params.rawToolResponses) return result;\n      return processResult(result as CallToolResult);\n    }\n  );\n}\n\n/**\n * Lookup all tools available in the server and register each as a Genkit tool.\n */\nexport async function registerAllTools(\n  ai: Genkit,\n  client: Client,\n  params: { name: string; serverName: string; rawToolResponses?: boolean }\n): Promise<void> {\n  let cursor: string | undefined;\n  while (true) {\n    const { nextCursor, tools } = await client.listTools({ cursor });\n    tools.forEach((t) => registerTool(ai, client, t, params));\n    cursor = nextCursor;\n    if (!cursor) break;\n  }\n}\n\n/**\n * Lookup all tools available in the server and fetches as a Genkit dynamic tool.\n */\nexport async function fetchDynamicTools(\n  ai: Genkit,\n  client: Client,\n  params: { name: string; serverName: string; rawToolResponses?: boolean }\n): Promise<ToolAction[]> {\n  let cursor: string | undefined;\n  let allTools: ToolAction[] = [];\n  while (true) {\n    const { nextCursor, tools } = await client.listTools({ cursor });\n    allTools.push(\n      ...tools.map((t) => createDynamicTool(ai, client, t, params))\n    );\n    cursor = nextCursor;\n    if (!cursor) break;\n  }\n  return allTools;\n}\n"],"mappings":"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","names":[]}