import {
  GenkitError
} from "genkit";
import { logger } from "genkit/logging";
import { fromMcpPromptMessage } from "./message.js";
function toSchema(args) {
  if (!args) return {};
  const schema = { type: "object", properties: {}, required: [] };
  for (const arg of args) {
    schema.properties[arg.name] = {
      type: "string",
      description: arg.description
    };
    if (arg.required) schema.required.push(arg.name);
  }
  return schema;
}
function registerPrompt(ai, client, prompt, params) {
  logger.debug(`[MCP] Registering MCP prompt ${params.name}/${prompt.name}`);
  ai.definePrompt({
    name: prompt.name,
    description: prompt.description || "",
    input: { jsonSchema: toSchema(prompt.arguments) },
    output: { format: "text" },
    metadata: { mcp: { _meta: prompt._meta || {} } },
    messages: async (args, { context }) => {
      logger.debug(
        `[MCP] Calling MCP prompt ${params.name}/${prompt.name} with arguments`,
        JSON.stringify(args)
      );
      const result = await client.getPrompt({
        name: prompt.name,
        arguments: args,
        _meta: context?.mcp?._meta
      });
      return result.messages.map(fromMcpPromptMessage);
    }
  });
}
function createExecutablePrompt(client, prompt, params) {
  const callPrompt = async (input, opts) => {
    logger.debug(`[MCP] Calling MCP prompt ${params.name}/${prompt.name}`);
    return params.ai.generate(callPrompt.render(input, opts));
  };
  callPrompt.ref = {
    name: prompt.name,
    metadata: {
      description: prompt.description,
      arguments: prompt.arguments,
      mcp: { _meta: prompt._meta || {} }
    }
  };
  callPrompt.stream = (input, opts) => {
    logger.debug(`[MCP] Streaming MCP prompt ${params.name}/${prompt.name}`);
    return params.ai.generateStream(callPrompt.render(input, opts));
  };
  callPrompt.render = async (input, opts) => {
    logger.debug(`[MCP] Rendering MCP prompt ${params.name}/${prompt.name}`);
    const result = await client.getPrompt({
      name: prompt.name,
      arguments: input,
      _meta: opts?.context?.mcp?._meta
    });
    const messages = result.messages.map(fromMcpPromptMessage);
    return {
      ...params.options,
      ...opts,
      messages
    };
  };
  callPrompt.asTool = async () => {
    throw new GenkitError({
      status: "UNIMPLEMENTED",
      message: `[MCP] prompt.asTool not supported with MCP`
    });
  };
  return callPrompt;
}
async function registerAllPrompts(ai, client, params) {
  let cursor;
  while (true) {
    const { nextCursor, prompts } = await client.listPrompts({ cursor });
    prompts.forEach((p) => registerPrompt(ai, client, p, params));
    cursor = nextCursor;
    if (!cursor) break;
  }
}
async function getExecutablePrompt(client, params) {
  let cursor;
  while (true) {
    const { nextCursor, prompts } = await client.listPrompts({ cursor });
    const maybePrompt = prompts.find(
      (p) => p.name === params.promptName
    );
    if (maybePrompt) {
      return createExecutablePrompt(client, maybePrompt, params);
    }
    cursor = nextCursor;
    if (!cursor) break;
  }
  return void 0;
}
async function fetchAllPrompts(client, params) {
  let cursor;
  const out = [];
  while (true) {
    const { nextCursor, prompts } = await client.listPrompts({ cursor });
    for (const p of prompts) {
      out.push(
        createExecutablePrompt(client, p, { ...params, promptName: p.name })
      );
    }
    cursor = nextCursor;
    if (!cursor) break;
  }
  return out;
}
export {
  fetchAllPrompts,
  getExecutablePrompt,
  registerAllPrompts
};
//# sourceMappingURL=prompts.mjs.map