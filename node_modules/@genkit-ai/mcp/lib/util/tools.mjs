import { z } from "genkit";
import { logger } from "genkit/logging";
const toText = (c) => c.map((p) => p.text || "").join("");
function processResult(result) {
  if (result.isError) return { error: toText(result.content) };
  if (result.content.every((c) => !!c.text)) {
    const text = toText(result.content);
    if (text.trim().startsWith("{") || text.trim().startsWith("[")) {
      try {
        return JSON.parse(text);
      } catch (e) {
        return text;
      }
    }
    return text;
  }
  if (result.content.length === 1) return result.content[0];
  return result;
}
function registerTool(ai, client, tool, params) {
  logger.debug(
    `[MCP] Registering tool '${params.name}/${tool.name}'' from server '${params.serverName}'`
  );
  ai.defineTool(
    {
      name: `${params.serverName}/${tool.name}`,
      description: tool.description || "",
      inputJsonSchema: tool.inputSchema,
      outputSchema: z.any(),
      metadata: { mcp: { _meta: tool._meta || {} } }
    },
    async (args) => {
      logger.debug(
        `[MCP] Calling MCP tool '${params.serverName}/${tool.name}' with arguments`,
        JSON.stringify(args)
      );
      const result = await client.callTool({
        name: tool.name,
        arguments: args
      });
      if (params.rawToolResponses) return result;
      return processResult(result);
    }
  );
}
function createDynamicTool(ai, client, tool, params) {
  return ai.dynamicTool(
    {
      name: `${params.serverName}/${tool.name}`,
      description: tool.description || "",
      inputJsonSchema: tool.inputSchema,
      outputSchema: z.any(),
      metadata: { mcp: { _meta: tool._meta || {} } }
    },
    async (args, { context }) => {
      logger.debug(
        `[MCP] calling tool '${params.serverName}/${tool.name}' in host '${params.name}'`
      );
      const result = await client.callTool({
        name: tool.name,
        arguments: args,
        _meta: context?.mcp?._meta
      });
      if (params.rawToolResponses) return result;
      return processResult(result);
    }
  );
}
async function registerAllTools(ai, client, params) {
  let cursor;
  while (true) {
    const { nextCursor, tools } = await client.listTools({ cursor });
    tools.forEach((t) => registerTool(ai, client, t, params));
    cursor = nextCursor;
    if (!cursor) break;
  }
}
async function fetchDynamicTools(ai, client, params) {
  let cursor;
  let allTools = [];
  while (true) {
    const { nextCursor, tools } = await client.listTools({ cursor });
    allTools.push(
      ...tools.map((t) => createDynamicTool(ai, client, t, params))
    );
    cursor = nextCursor;
    if (!cursor) break;
  }
  return allTools;
}
export {
  fetchDynamicTools,
  registerAllTools
};
//# sourceMappingURL=tools.mjs.map