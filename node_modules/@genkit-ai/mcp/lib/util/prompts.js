"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var prompts_exports = {};
__export(prompts_exports, {
  fetchAllPrompts: () => fetchAllPrompts,
  getExecutablePrompt: () => getExecutablePrompt,
  registerAllPrompts: () => registerAllPrompts
});
module.exports = __toCommonJS(prompts_exports);
var import_genkit = require("genkit");
var import_logging = require("genkit/logging");
var import_message = require("./message.js");
function toSchema(args) {
  if (!args) return {};
  const schema = { type: "object", properties: {}, required: [] };
  for (const arg of args) {
    schema.properties[arg.name] = {
      type: "string",
      description: arg.description
    };
    if (arg.required) schema.required.push(arg.name);
  }
  return schema;
}
function registerPrompt(ai, client, prompt, params) {
  import_logging.logger.debug(`[MCP] Registering MCP prompt ${params.name}/${prompt.name}`);
  ai.definePrompt({
    name: prompt.name,
    description: prompt.description || "",
    input: { jsonSchema: toSchema(prompt.arguments) },
    output: { format: "text" },
    metadata: { mcp: { _meta: prompt._meta || {} } },
    messages: async (args, { context }) => {
      import_logging.logger.debug(
        `[MCP] Calling MCP prompt ${params.name}/${prompt.name} with arguments`,
        JSON.stringify(args)
      );
      const result = await client.getPrompt({
        name: prompt.name,
        arguments: args,
        _meta: context?.mcp?._meta
      });
      return result.messages.map(import_message.fromMcpPromptMessage);
    }
  });
}
function createExecutablePrompt(client, prompt, params) {
  const callPrompt = async (input, opts) => {
    import_logging.logger.debug(`[MCP] Calling MCP prompt ${params.name}/${prompt.name}`);
    return params.ai.generate(callPrompt.render(input, opts));
  };
  callPrompt.ref = {
    name: prompt.name,
    metadata: {
      description: prompt.description,
      arguments: prompt.arguments,
      mcp: { _meta: prompt._meta || {} }
    }
  };
  callPrompt.stream = (input, opts) => {
    import_logging.logger.debug(`[MCP] Streaming MCP prompt ${params.name}/${prompt.name}`);
    return params.ai.generateStream(callPrompt.render(input, opts));
  };
  callPrompt.render = async (input, opts) => {
    import_logging.logger.debug(`[MCP] Rendering MCP prompt ${params.name}/${prompt.name}`);
    const result = await client.getPrompt({
      name: prompt.name,
      arguments: input,
      _meta: opts?.context?.mcp?._meta
    });
    const messages = result.messages.map(import_message.fromMcpPromptMessage);
    return {
      ...params.options,
      ...opts,
      messages
    };
  };
  callPrompt.asTool = async () => {
    throw new import_genkit.GenkitError({
      status: "UNIMPLEMENTED",
      message: `[MCP] prompt.asTool not supported with MCP`
    });
  };
  return callPrompt;
}
async function registerAllPrompts(ai, client, params) {
  let cursor;
  while (true) {
    const { nextCursor, prompts } = await client.listPrompts({ cursor });
    prompts.forEach((p) => registerPrompt(ai, client, p, params));
    cursor = nextCursor;
    if (!cursor) break;
  }
}
async function getExecutablePrompt(client, params) {
  let cursor;
  while (true) {
    const { nextCursor, prompts } = await client.listPrompts({ cursor });
    const maybePrompt = prompts.find(
      (p) => p.name === params.promptName
    );
    if (maybePrompt) {
      return createExecutablePrompt(client, maybePrompt, params);
    }
    cursor = nextCursor;
    if (!cursor) break;
  }
  return void 0;
}
async function fetchAllPrompts(client, params) {
  let cursor;
  const out = [];
  while (true) {
    const { nextCursor, prompts } = await client.listPrompts({ cursor });
    for (const p of prompts) {
      out.push(
        createExecutablePrompt(client, p, { ...params, promptName: p.name })
      );
    }
    cursor = nextCursor;
    if (!cursor) break;
  }
  return out;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  fetchAllPrompts,
  getExecutablePrompt,
  registerAllPrompts
});
//# sourceMappingURL=prompts.js.map