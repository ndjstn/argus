"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var host_exports = {};
__export(host_exports, {
  GenkitMcpHost: () => GenkitMcpHost
});
module.exports = __toCommonJS(host_exports);
var import_logging = require("genkit/logging");
var import_client = require("./client.js");
class GenkitMcpHost {
  name;
  _clients = {};
  _clientStates = {};
  _readyListeners = [];
  _ready = false;
  _dynamicActionProvider;
  roots;
  rawToolResponses;
  constructor(options) {
    this.name = options.name || "genkit-mcp";
    this.rawToolResponses = options.rawToolResponses;
    this.roots = options.roots;
    if (options.mcpServers) {
      this.updateServers(options.mcpServers);
    } else {
      this._ready = true;
    }
  }
  set dynamicActionProvider(dap) {
    this._dynamicActionProvider = dap;
  }
  _invalidateCache() {
    if (this._dynamicActionProvider) {
      this._dynamicActionProvider.invalidateCache();
    }
  }
  /**
   * Returns a Promise that resolves when the host has attempted to connect
   * to all configured clients, or rejects if a critical error occurs during
   * the initial connection phase.
   */
  async ready() {
    if (this._ready) return;
    return new Promise((resolve, reject) => {
      this._readyListeners.push({ resolve, reject });
    });
  }
  /**
   * Connects to a single MCP server defined by the provided configuration.
   * If a server with the same name already exists, it will be disconnected first.
   * Stores the client and transport references internally. Handles connection errors
   * by marking the server as disabled.
   * @param serverName The name to assign to this server connection.
   * @param config The configuration object for the server.
   */
  async connect(serverName, config) {
    const existingEntry = this._clients[serverName];
    if (existingEntry) {
      try {
        await existingEntry._disconnect();
      } catch (e) {
        existingEntry.disable();
        this.setError(serverName, {
          message: `[MCP Host] Error disconnecting from existing connection for ${serverName}`,
          detail: `Details: ${e}`
        });
      }
    }
    import_logging.logger.debug(
      `[MCP Host] Connecting to MCP server '${serverName}' in host '${this.name}'.`
    );
    try {
      const client = new import_client.GenkitMcpClient({
        name: this.name,
        serverName,
        mcpServer: { ...config, roots: config.roots || this.roots },
        rawToolResponses: this.rawToolResponses
      });
      this._clients[serverName] = client;
    } catch (e) {
      this.setError(serverName, {
        message: `[MCP Host] Error connecting to ${serverName} with config ${config}`,
        detail: `Details: ${e}`
      });
    }
    this._invalidateCache();
  }
  /**
   * Disconnects the specified MCP server and removes its registration
   * from this client instance.
   * @param serverName The name of the server to disconnect.
   */
  async disconnect(serverName) {
    const client = this._clients[serverName];
    if (!client) {
      import_logging.logger.warn(`[MCP Host] unable to find server ${serverName}`);
      return;
    }
    import_logging.logger.debug(
      `[MCP Host] Disconnecting MCP server '${serverName}' in host '${this.name}'.`
    );
    try {
      await client._disconnect();
    } catch (e) {
      client.disable();
      this.setError(serverName, {
        message: `[MCP Host] Error disconnecting from existing connection for ${serverName}`,
        detail: `Details: ${e}`
      });
    }
    delete this._clients[serverName];
    this._invalidateCache();
  }
  /**
   * Temporarily disables a server connection. Closes the underlying transport
   * but retains the server's configuration. Does nothing if the server is
   * already disabled.
   * @param serverName The name of the server to disable.
   */
  async disable(serverName) {
    const client = this._clients[serverName];
    if (!client) {
      import_logging.logger.warn(`[MCP Host] unable to find server ${serverName}`);
      return;
    }
    if (!client.isEnabled()) {
      import_logging.logger.warn(`[MCP Host] server ${serverName} already disabled`);
      return;
    }
    import_logging.logger.debug(
      `[MCP Host] Disabling MCP server '${serverName}' in host '${this.name}'`
    );
    await client.disable();
    this._invalidateCache();
  }
  /**
   * Enables a server connection, including previously disabled ones. Attempts to reconnect
   * using the stored transport. Does nothing if the server is not disabled.
   * @param serverName The name of the server to re-enable.
   */
  async enable(serverName) {
    const client = this._clients[serverName];
    if (!client) {
      import_logging.logger.warn(`[MCP Host] unable to find server ${serverName}`);
      return;
    }
    import_logging.logger.debug(
      `[MCP Host] Reenabling MCP server '${serverName}' in host '${this.name}'`
    );
    try {
      await client.enable();
    } catch (e) {
      client.disable();
      this.setError(serverName, {
        message: `[MCP Host] Error reenabling server ${serverName}`,
        detail: `Details: ${e}`
      });
    }
    this._invalidateCache();
  }
  /**
   * Closes and then restarts the transport connection for the specified server.
   * Useful for attempting to recover from connection issues without full
   * reconfiguration.
   * @param serverName The name of the server to reconnect.
   */
  async reconnect(serverName) {
    const client = this._clients[serverName];
    if (!client) {
      import_logging.logger.warn(`[MCP Host] unable to find server ${serverName}`);
      return;
    }
    import_logging.logger.debug(
      `[MCP Host] Restarting connection to MCP server '${serverName}' in host '${this.name}'`
    );
    try {
      await client.restart();
    } catch (e) {
      client.disable();
      this.setError(serverName, {
        message: `[MCP Host] Error restarting to server ${serverName}`,
        detail: `Details: ${e}`
      });
    }
    this._invalidateCache();
  }
  /**
   * Updates the connections based on a provided map of server configurations.
   * - Connects any new servers defined in `mcpServers`.
   * - Disconnects any servers currently connected but not present in `mcpServers`.
   * - Reconnects existing servers if their configuration appears to have changed (implicitly handled by `connectServer`).
   * Sets the client's ready state once all connection attempts are complete.
   * @param mcpServers A record mapping server names to their configurations.
   */
  updateServers(mcpServers) {
    this._ready = false;
    const newServerNames = new Set(Object.keys(mcpServers));
    const currentServerNames = new Set(Object.keys(this._clients));
    const promises = [];
    for (const serverName in mcpServers) {
      promises.push(this.connect(serverName, mcpServers[serverName]));
    }
    for (const serverName of currentServerNames) {
      if (!newServerNames.has(serverName)) {
        this.disconnect(serverName);
      }
    }
    Promise.all(promises).then(() => {
      this._ready = true;
      while (this._readyListeners.length) {
        this._readyListeners.pop()?.resolve();
      }
    }).catch((err) => {
      while (this._readyListeners.length) {
        this._readyListeners.pop()?.reject(err);
      }
    });
    this._invalidateCache();
  }
  /**
   * Retrieves all tools from all connected and enabled MCP clients managed by
   * this instance. This method waits for the host to be ready (all initial
   * connection attempts made) before fetching tools.
   *
   * It iterates through each managed `GenkitMcpClient`, and if the client is
   * not disabled, it calls the client's `getTools` method to fetch its
   * available tools. These are then aggregated into a single array.
   *
   * This is useful for dynamically providing a list of all available MCP tools
   * to Genkit, for example, when setting up a Genkit plugin.
   *
   * ```ts
   * const mcpHost = createMcpHost({ ... });
   * // In your Genkit configuration:
   * // const allMcpTools = await McpHost.getActiveTools(ai);
   * // Then, these tools can be used or registered with Genkit.
   * ```
   *
   * @param ai The Genkit instance, used by individual clients to define dynamic
   * tools.
   * @returns A Promise that resolves to an array of `ToolAction` from all
   * active MCP clients.
   */
  async getActiveTools(ai) {
    await this.ready();
    let allTools = [];
    for (const serverName in this._clients) {
      const client = this._clients[serverName];
      if (client.isEnabled() && !this.hasError(serverName)) {
        try {
          const tools = await client.getActiveTools(ai);
          allTools.push(...tools);
        } catch (e) {
          import_logging.logger.error(
            `Error fetching active tools from client ${serverName}.`,
            JSON.stringify(e)
          );
        }
      }
    }
    return allTools;
  }
  /**
   * Retrieves all resources from all connected and enabled MCP clients managed by
   * this instance. This method waits for the host to be ready (all initial
   * connection attempts made) before fetching resources.
   *
   * It iterates through each managed `GenkitMcpClient`, and if the client is
   * not disabled, it calls the client's `getActiveResources` method to fetch its
   * available resources. These are then aggregated into a single array.
   *
   * This is useful for dynamically providing a list of all available MCP resources
   * to Genkit, for example, when setting up a Genkit plugin.
   *
   * @param ai The Genkit instance, used by individual clients to define dynamic
   * resources.
   * @returns A Promise that resolves to an array of `DynamicResourceAction` from all
   * active MCP clients.
   */
  async getActiveResources(ai) {
    await this.ready();
    let allResources = [];
    for (const serverName in this._clients) {
      const client = this._clients[serverName];
      if (client.isEnabled() && !this.hasError(serverName)) {
        try {
          const resources = await client.getActiveResources(ai);
          allResources.push(...resources);
        } catch (e) {
          import_logging.logger.error(
            `Error fetching active resources from client ${serverName}.`,
            JSON.stringify(e)
          );
        }
      }
    }
    return allResources;
  }
  /**
   * Retrieves all prompts from all connected and enabled MCP clients managed by
   * this instance. This method waits for the host to be ready (all initial
   * connection attempts made) before fetching prompts.
   *
   * It iterates through each managed `GenkitMcpClient`, and if the client is
   * not disabled, it calls the client's `getActivePrompts` method to fetch its
   * available prompts. These are then aggregated into a single array.
   *
   * This is useful for dynamically providing a list of all available MCP prompts
   * to Genkit, for example, when setting up a Genkit plugin.
   *
   * @param ai The Genkit instance, used by individual clients to define dynamic
   * prompts.
   * @returns A Promise that resolves to an array of `ExecutablePrompt` from all
   * active MCP clients.
   */
  async getActivePrompts(ai) {
    await this.ready();
    let allPrompts = [];
    for (const serverName in this._clients) {
      const client = this._clients[serverName];
      if (client.isEnabled() && !this.hasError(serverName)) {
        allPrompts.push(...await client.getActivePrompts(ai));
      }
    }
    return allPrompts;
  }
  /**
   * Get the specified prompt as an `ExecutablePrompt` available through the
   * specified server. If no such prompt is found, return undefined.
   */
  async getPrompt(ai, serverName, promptName, opts) {
    await this.ready();
    const client = this._clients[serverName];
    if (!client) {
      import_logging.logger.error(`No client found with name '${serverName}'.`);
      return;
    }
    if (this.hasError(serverName)) {
      const errorStringified = JSON.stringify(
        this._clientStates[serverName].error
      );
      import_logging.logger.error(
        `Client '${serverName}' is in an error state. ${errorStringified}`
      );
    }
    if (client.isEnabled()) {
      const prompt = await client.getPrompt(ai, promptName, opts);
      if (!prompt) {
        import_logging.logger.error(
          `[MCP Host] Unable to fetch the specified ${promptName} in server ${serverName}.`
        );
        return;
      }
      return prompt;
    }
    return;
  }
  async close() {
    for (const client of Object.values(this._clients)) {
      await client._disconnect();
    }
    this._invalidateCache();
  }
  /** Helper method to track and log client errors. */
  setError(serverName, error) {
    this._clientStates[serverName] = { error };
    import_logging.logger.warn(
      `An error has occured while managing your MCP client '${serverName}'. The client may be disabled to avoid further issues. Please resolve the issue and reenable the client '${serverName}' to continue using its resources.`
    );
    import_logging.logger.warn(error);
  }
  hasError(serverName) {
    return this._clientStates[serverName] && !!this._clientStates[serverName].error;
  }
  /**
   * Returns an array of all active clients.
   */
  get activeClients() {
    return Object.values(this._clients).filter((c) => c.isEnabled());
  }
  /**
   * Returns the client by name.
   */
  getClient(name) {
    return this._clients[name];
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GenkitMcpHost
});
//# sourceMappingURL=host.js.map