import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import {
  ListRootsRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
import {
  GenkitError
} from "genkit";
import { logger } from "genkit/logging";
import {
  fetchAllPrompts,
  fetchDynamicTools,
  getExecutablePrompt,
  transportFrom
} from "../util";
import { fetchDynamicResources } from "../util/resource";
class GenkitMcpClient {
  _server;
  _dynamicActionProvider;
  sessionId;
  name;
  suppliedServerName;
  version;
  serverConfig;
  rawToolResponses;
  disabled;
  roots;
  _readyListeners = [];
  _ready = false;
  constructor(options) {
    this.name = options.name;
    this.suppliedServerName = options.serverName;
    this.version = options.version || "1.0.0";
    this.serverConfig = options.mcpServer;
    this.rawToolResponses = !!options.rawToolResponses;
    this.disabled = !!options.mcpServer.disabled;
    this.roots = options.mcpServer.roots;
    this.sessionId = options.sessionId;
    this._initializeConnection();
  }
  set dynamicActionProvider(dap) {
    this._dynamicActionProvider = dap;
  }
  _invalidateDapCache() {
    if (this._dynamicActionProvider) {
      this._dynamicActionProvider.invalidateCache();
    }
  }
  get serverName() {
    return this.suppliedServerName ?? this._server?.client.getServerVersion()?.name ?? "unknown-server";
  }
  async updateRoots(roots) {
    this.roots = roots;
    await this._server?.client.sendRootsListChanged();
    this._invalidateDapCache();
  }
  /**
   * Sets up a connection based on a provided map of server configurations.
   * - Reconnects existing servers if their configuration appears to have
   *   changed (implicitly handled by `connectServer`).
   * - Sets the client's ready state once all connection attempts are complete.
   * @param mcpServers A record mapping server names to their configurations.
   */
  async _initializeConnection() {
    this._ready = false;
    try {
      await this._connect();
      this._ready = true;
      while (this._readyListeners.length) {
        this._readyListeners.pop()?.resolve();
      }
    } catch (err) {
      while (this._readyListeners.length) {
        this._readyListeners.pop()?.reject(err);
      }
    }
    if (this.roots) {
      await this.updateRoots(this.roots);
    }
    this._invalidateDapCache();
  }
  /**
   * Returns a Promise that resolves when the client has attempted to connect
   * to all configured servers, or rejects if a critical error occurs during
   * the initial connection phase.
   */
  async ready() {
    if (this._ready) return;
    return new Promise((resolve, reject) => {
      this._readyListeners.push({ resolve, reject });
    });
  }
  /**
   * Connects to a single MCP server defined by the provided configuration.
   * @param config The configuration object for the server.
   */
  async _connect() {
    if (this._server) await this._server.transport.close();
    this._invalidateDapCache();
    logger.debug(
      `[MCP Client] Connecting MCP server '${this.serverName}' in client '${this.name}'.`
    );
    const { transport, type: transportType } = await transportFrom(
      this.serverConfig,
      this.sessionId
    );
    if (!transport) {
      throw new GenkitError({
        status: "INVALID_ARGUMENT",
        message: `[MCP Client] Could not determine valid transport config from supplied options.`
      });
    }
    let error;
    const client = new Client(
      { name: this.name, version: this.version },
      { capabilities: { roots: { listChanged: true } } }
    );
    client.setRequestHandler(ListRootsRequestSchema, () => {
      logger.debug(`[MCP Client] fetching roots for ${this.name}`);
      return { roots: this.roots || [] };
    });
    try {
      await client.connect(transport);
    } catch (e) {
      logger.warn(
        `[MCP Client] Error connecting server via ${transportType} transport: ${e}`
      );
      this.disabled = true;
      error = e.toString();
    }
    this._server = {
      client,
      transport,
      error
    };
    this._invalidateDapCache();
  }
  /**
   * Disconnects the MCP server and removes its registration
   * from this client instance.
   */
  async _disconnect() {
    if (this._server) {
      logger.debug(
        `[MCP Client] Disconnecting MCP server in client '${this.name}'.`
      );
      await this._server.client.close();
      this._server = void 0;
      this._invalidateDapCache();
    }
  }
  /**
   * Disables a server. Closes the underlying transport and server's configuration. Does nothing if the server is
   * already disabled.
   */
  async disable() {
    if (!this.isEnabled()) return;
    if (this._server) {
      logger.debug(
        `[MCP Client] Disabling MCP server in client '${this.name}'`
      );
      await this._disconnect();
      this.disabled = true;
      this._invalidateDapCache();
    }
  }
  /**
   * Whether this client-server connection is enabled or not.
   */
  isEnabled() {
    return !this.disabled;
  }
  /**
   * Enables a server connection, including previously disabled ones. Does nothing if the
   * server is not disabled.
   */
  async enable() {
    if (this.isEnabled()) return;
    logger.debug(`[MCP Client] Reenabling MCP server in client '${this.name}'`);
    await this._initializeConnection();
    this.disabled = !!this._server.error;
    this._invalidateDapCache();
  }
  /**
   * Closes and then restarts the transport connection for the specified server.
   * Useful for attempting to recover from connection issues without full
   * reconfiguration.
   */
  async restart() {
    if (this._server) {
      logger.debug(
        `[MCP Client] Restarting connection to MCP server in client '${this.name}'`
      );
      await this._disconnect();
      await this._initializeConnection();
      this._invalidateDapCache();
    }
  }
  /**
   * Fetches all tools available through this client, if the server
   * configuration is not disabled.
   */
  async getActiveTools(ai) {
    await this.ready();
    let tools = [];
    if (this._server) {
      const capabilities = this._server.client.getServerCapabilities();
      if (capabilities?.tools)
        tools.push(
          ...await fetchDynamicTools(ai, this._server.client, {
            rawToolResponses: this.rawToolResponses,
            serverName: this.serverName,
            name: this.name
          })
        );
    }
    return tools;
  }
  /**
   * Fetches all resources available through this client, if the server
   * configuration is not disabled.
   */
  async getActiveResources(ai) {
    await this.ready();
    let resources = [];
    if (this._server) {
      const capabilities = this._server.client.getServerCapabilities();
      if (capabilities?.resources)
        resources.push(
          ...await fetchDynamicResources(ai, this._server.client, {
            serverName: this.serverName,
            name: this.name
          })
        );
    }
    return resources;
  }
  /**
   * Fetches all active prompts available through this client, if the server
   * configuration supports prompts.
   * @param ai The Genkit instance.
   * @param options Optional prompt generation options.
   * @returns A promise that resolves to an array of ExecutablePrompt.
   */
  async getActivePrompts(ai, options) {
    if (this._server?.client.getServerCapabilities()?.prompts) {
      return fetchAllPrompts(this._server.client, {
        ai,
        serverName: this.serverName,
        name: this.name,
        options
      });
    }
    return [];
  }
  /**
   * Get the specified prompt as an `ExecutablePrompt` available through this
   * client. If no such prompt is found, return undefined.
   */
  async getPrompt(ai, promptName, opts) {
    await this.ready();
    if (this._server) {
      const capabilities = await this._server.client.getServerCapabilities();
      if (capabilities?.prompts) {
        return await getExecutablePrompt(this._server.client, {
          ai,
          serverName: this.name,
          promptName,
          name: this.name,
          options: opts
        });
      }
      logger.debug(`[MCP Client] No prompts are found in this MCP server.`);
    }
    return;
  }
  /** Returns the underlying MCP SDK client if one has been initialized. */
  get mcpClient() {
    return this._server?.client;
  }
}
export {
  GenkitMcpClient
};
//# sourceMappingURL=client.mjs.map